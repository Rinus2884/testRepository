/*
    []  lambda introducer 람다 함수 소개자
    캡처 절 capture clause
    람다 함수 외부( 그리고 람다함수가 있는 지역의 ) 의 변수를 캡쳐한다는 의미의 연산자

    캡쳐 규칙

    []  아무것도 캡처하지 않음
    [&]  '모든 외부변수'를 '레퍼런스'로 캡처
    [=]  '모든 외부변수'를 '값'으로 캡처

    [x]   외부변수 x 를 '값'으로 캡처
    [x,y]  외부변수 x,y 를 '값'으로 캡처
    [&x]   외부변수 x 를 '레퍼런스'로 캡처


    [&x, &y]   외부변수 x, 외부변수 y 를 '레퍼런스'로 캡처
    [&x,y]   외부변수 x는 레퍼런스로 외부변수 y는 '값'으로 캡처
    [x, &y]   외부변수 x는 '값'으로 외부변수 y는  '레퍼런스'로 캡처


    [&,x]   외부변수 x는 '값'으로, 나머지는 모두 '레퍼런스'로 캡처
    [=,&x]   외부변수 x는 레퍼런스로 나머지는 모두 '값'으로 캡처 


    값으로 캡춰된 변수는 
    람다함수 내부에서 값을 변경하는 것이 금지되어 있다.
    ( 값으로 캡춰된 변수는 const 특성을 가진다 )
    <-- 그러므로, 람다함수 내부에서 캡춰된 외부변수의 값을 변경하고 싶다면
        레퍼런스로 캡춰해야 한다.


*/

#include <iostream>
using namespace std;

int main()
{
    //외부변수

    int tA = 3;
    int tB = 2;
    int tResult = 0;

    //[=]() {tResult = tA + tB; };                    //이 경우 tResult는 const


    [=, &tResult]() {tResult = tA + tB; }();        //이 경우는 리턴타입이 void로 해석
    cout << "tResult: " << tResult << endl;


    tA = 3;
    tB = 2;
    tResult = 0;


    tResult = [=]() {return tA + tB; }();           //이 경우는 리턴타입이 int로 해석
    cout << "tResult: " << tResult << endl;


    //p.s.
    []() {cout << "this is lambda. " << endl; }();
    //<-- 람다함수는 선언, 정의, 호출을 한 곳에 표기가능하다.
    //  <-- 코드 표기상으로 보았을 때 '변경의 국지화'가 일어난다.

    //람다함수는 실제로 함수가 만들어지는 것이 아니다.
    //함수의 정의 형식이 코드 상에 만들어지긴 하지만
    //호출부에 쌩제어구조의 바이너리가 컴파일되어 만들어져 삽입되는 것이다.
    //<-- 함수의 호출비용이 없으므로 함수로 만든것보다 '빠르다'.


    return 0;
    
}

